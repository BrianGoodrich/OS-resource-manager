#Author: Brian Goodrich Project 5 CS 4760 11/22/22

- The purpose of this project is to serve as a simulated resource manager for an operating system. 

- This project has two executables, oss and user. Oss will handle launching and controlling the user processes.

- Conceptually OSS is looping continuously incrementing a logical clock that resides in shared memory, and it will periodically spawn new user processes every time 2 seconds passes on this logical clock. The limit for these user processes is 18 running processes at 1 time, and 40 total process generations.

- There are 3 different instances of shared memory, one for 18 shared process structures, one for 20 resources, and one for the system clock. The shared memory for resources and the system clock is only modified by the OSS process, and the user process will only read values from the resources and clock and will only modify their own process block. Initially I had the processes just as a single integer and was accessing each process by index, but I found it easier for the deadlock avoidance and a few other reasons to just make it a structure so that it could have a max claims array, allocation array, requests integer for specifying which resource the process was requesting, an integer for if it is blocked, and an integer for if it has terminated.
	- Note: I chose to create 21 resources in shared memory, and only ever access resources 1-21 as to avoid having to use index 0. The reason being when releasing a resource I set that resource index to -1 for example, and this isn’t possible for index 0, so I avoided it.

- OSS will not only spawn new user processes periodically but it will handle resource requests from the user processes as well. It looks over all the active processes that are not blocked to see if there are any resource requests from a process. The first request it comes across it will call the deadlock avoidance algorithm function safe() to see if we are currently in a safe state. If the deadlock avoidance function safe() returns a 1 it will grant these resources, updating the allocation in the process shared memory as well as the resource shared memory and set the processes request flag “resRequest” to 30 so the user process will know it has been granted its previously requested resource. If the avoidance algorithm returns 0, that means that the request could lead to a deadlock, so we will suspend the process. To suspend a process we put it in our blocked queue, and set its blocked variable to 1 in shared memory. This will mean that while blocked, OSS will no longer consider its request. In the case that a user process releases a resource, we will look at our blocked queue 1 by 1 and see if any of them can be granted their request after this release. If it can be granted, we remove the process from the queue and unblock it by setting its blocked variable to 0. If it cannot be granted it is placed at the end of the queue. 

	- OSS is also the only process allowed to write to a file. When reading the assignment document the “verbose” setting description had some typos in it saying that “When verbose is off, it should only indicate what resources are requested and granted, and available resources. When verbose is off, it should only log when a deadlock is detected, and how it was resolved.”. This was confusing because we were told to use a deadlock avoidance algorithm, thus a deadlock should not be possible, so if I did implement a verbose setting so that when it was off it would only output when there is a deadlock, it would never output anything because as of now my program will not grant a request to generate a deadlock scenario. So I chose to just have the program output relevant information to a file, and there is no verbose setting. 

- User process will generate a max claims array upon creation, and will begin requesting resources in a linear way. By linear way I mean that each resource will request resources in order 1-20, there were no specifications to my knowledge on how to do this so this was the most straightforward way for me to approach it. User process generates an interval from 1 - 500,000,000 nanoseconds that it will wait for to pass on the shared memory clock before it requests, or releases a resource, and then will wait until the next second passes to request again after the same nanosecond interval. After the interval passes the user process will check to see if it has been granted a resource, if it has it will then release that resource, as it is done with it. So user is only holding each resource it is granted for one cycle from interval to interval. I am not 100% sure this is correct but this is the way that I understood we talked about it in class when it was said that the user process will only hold one process at a time before requesting the next one. This still allows for some conflicts of a process holding a resource when another requests, and one process being placed into wait queue waiting for the other process to release. This seems to work fine for me when running the program. If user has not been granted a resource it will loop continuously until it is granted that resource. It will terminate if it has been granted all of the resources that it needed to complete.

	- User will send a request for a resource by setting the resource number in its process struct resRequest. This is what OSS will read to see what process has requested which resource. User does have a 30 second timer so that if something were to go wrong in OSS and user doesn’t get to finish it will eventually end.

- Deadlock Avoidance Algorithm - I implemented the deadlock avoidance bankers algorithm based on the pseudo code from the lecture slides, its logic is identical and seems to work fine. It returns a 1 if safe, and 0 if not safe. The main difference in my algorithm is that instead of building a state structure and passing it into the safe() function, I just use my shared memory, since shared memory works as an array I essentially have an array of resources and processes that within those structures there is totalAvailable resources, current allocation, and for processes we have allocation for that specific process, and max claims for it as well. Which we use all of these to build current availability of resources in the safe() function, and then we go through the steps of the algorithm finding a process that can be satisfied by current available resources, simulating releasing its resources, then looping again to keep trying each process seeing if it can be compelted. If there is a resource that cannot be completed with current available we are in an unsafe state and 0 will be returned.


- Termination - OSS will terminate after 5 real life seconds, or after 40 user processes in total have been created. If it reaches 18 active user processes it will wait until one has finished to continue creating more.
	- OSS and User also both have SIGINT handling so that if you have to ctrl+C it will destroy shared memory and terminate.

- Running the program - to run the program you can type "make" to do the compilation, and run with "./oss". This program takes no arguments, and outputs to a file called "output.txt". It will output to the file when a process requests a resource, when a process releases a resource, when OSS determines it is safe to allocate to a process, when a process enters the blocked state, and when it is removed from the blocked state.
